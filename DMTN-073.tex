\documentclass[DM,toc]{lsstdoc}

\usepackage{hyperref}
\usepackage{graphicx}

\newcommand{\tblref}[1]{\hyperref[tbl:#1]{#1}}

\newcommand{\coltable}[1]{
    \begin{table}
        {\footnotesize
        \include{generated/#1_columns}}
        \caption{#1 Columns}
        \label{tbl:#1}
    \end{table}
}

\newcommand{\relgraph}[3][width=0.8\textwidth]{
    \begin{figure}
        \centering
        \includegraphics[#1]{generated/#2_relationships}
        \caption{#3}
        \label{rel:#2}
    \end{figure}
}

\title{The Gen3 Butler Registry Schema}

\author{Jim Bosch}

\setDocRef{DMTN-073}
\date{2018-02-19}
\setDocUpstreamLocation{\url{https://github.com/lsst-dm/dmtn-073}}

\setDocAbstract{%
Documentation for the SQL schema that will be used to manage datasets in the Gen3 Butler.
}

\setDocChangeRecord{%
\addtohist{}{2018-02-19}{Initial version.}{J.~Bosch}
%\addtohist{1}{yyyy-mm-dd}{Future changes}{Future person}
}

\begin{document}

\maketitle

\section{Overview}
\label{sec:overview}

This document is a human-readable description of the minimal SQL schema that will be used in the Gen3 Butler's Registry component.

While some Registry instances may have additional tables, all must provide at least the tables and views described here, and are generally expected to use the mechanisms described here for most extensions.

The normative, machine-readable version of the minimal schema can be found at:

\verb`daf_butler:config/registry/default_schema.yaml`.

The tables and figures in this document (including the descriptions of table columns) are generated from the contents of that file.

\relgraph[height=0.9\textheight]{All}{
    Table Relationships.  Colors are for disambiguation only.
}

\section{Datasets}
\label{sec:datasets}

\subsubsection{Dataset}
\label{sec:dataset}

The Dataset contains a single record for every discrete unit of data managed by the Registry, and acts as a sort of hub for the rest of the schema: nearly all other tables join to it, either to label datasets (Section~\ref{sec:dataunits}), provide provenance information and define groups (Section~\ref{sec:collections-and-provenance}), or connect to the Datastores that actually store them (Section~\ref{sec:datastore-information}).

Dataset uses a compound primary key consisting of two fields, \texttt{dataset\_id} and \texttt{registry\_id}.
The former is auto-increment, and the latter is used to disambiguate different ``incrementers''; see Section~\ref{sec:cross-registry-auto-increment-keys} for information on this pattern.

Finding a particular dataset (assuming one does not already have the primary key values or provenance information) typically requires three pieces of information:
\begin{itemize}
    \item its \hyperref[sec:DatasetType]{DatasetType} (e.g. \texttt{src});
    \item one or more \hyperref[sec:collections]{Collections} to search;
    \item a set of \hyperref[sec:dataunits]{DataUnit} values.
\end{itemize}

The full set of Dataset columns can be found in Table~\ref{tbl:Dataset}.

\coltable{Dataset}


\subsubsection{DatasetType}
\label{sec:DatasetType}

A DatasetType captures two properties of a Dataset and associates them with a string name:
\begin{itemize}
    \item a \emph{StorageClass};
    \item a set of \hyperref[sec:dataunits]{DataUnit} keys whose corresponding values must be provided to uniquely identify a \tblref{Dataset} within a \hyperref[sec:collections]{Collection}.
\end{itemize}

StorageClasses are things that Datastores know how to serialize.
They are closely related to the in-memory data structure or class object used by a Dataset, and in most cases they have a one-to-one relationship with those concepts.
In other cases, a StorageClass may just correspond to an intermediate opaque serialization interface (e.g. Python's \texttt{pickle}) that can be used to store objects of many different types.
Opaque StorageTypes generally severely limit the flexibility of Datastores to choose how objects are stored and make it impossible to retreive components or slices from those datasets, but they provide a way to save almost-arbitrary objects to Datastores without adding a new StorageClass each time.
Because the full set of StorageClasses must in general be known to all Datastores, the set of supported StorageClasses and their definitions is maintained in code, not any particular Registry.

DatasetTypes are expected to be much more dynamic than StorageClasses or \hyperref[sec:dataunits]{DataUnits}; developers should be able to easily define new DatasetTypes by mixing an existing StorageClass with a set of existing \hyperref[sec:dataunits]{DataUnits} and a new name.
We nevertheless expect DatasetType creation to be quite rare compared with Dataset creation, and certain Registries may limit DatasetType creation to superusers or require adherence to strict naming conventions (see Section~\ref{sec:namespaces-for-collections-and-datasettypes}).

The columns of the DatasetType table itself are shown in Table~\ref{tbl:DatasetType}.
The list of associated \hyperref[sec:dataunits]{DataUnits} is managed by the \tblref{DatasetTypeUnits} table, and a list of associated metadata tables (see Section~\ref{sec:datasettype-metadata}) is managed by the \tblref{DatasetTypeMetadata} table.

\coltable{DatasetType}
\coltable{DatasetTypeUnits}
\coltable{DatasetTypeMetadata}


\subsection{Composite Datasets}
\label{sec:composite-datasets}

Datasets may be composite: they may contain discrete named child Datasets that can be retrieved efficiently from a parent or combined to form a new parent.

The structure of composite dataset is fully defined by its StorageClass; all Datasets with a particular StorageClass will have the same set of component nnames and component StorageClasses (though some StorageClasses may permit a component to be None/null).

The representation of composite datasets in the registry schema is still TDB.

\section{DataUnits}
\label{sec:dataunits}

\subsection{Fundamental DataUnits}
\label{sec:fundamental-dataunits}

\subsection{Camera DataUnits}
\label{sec:camera-dataunits}

\subsection{SkyMap DataUnits}
\label{sec:skymap-dataunits}

\subsection{Joins Between DataUnits}
\label{sec:joins-between-dataunits}


\section{Collections and Provenance}
\label{sec:collections-and-provenance}

\subsection{Collections}
\label{sec:collections}

\coltable{DatasetCollection}

\subsection{Execution}
\label{sec:excution}

Records of the \tblref{Execution} table can be used to represent any step in a production.
Executions are frequently associated one-to-one with records of other tables that use the same primary key fields (such as \hyperref[sec:run]{Run} and \hyperref[sec:quantum]{Quantum}).
Conceptually these tables are Execution specializations.
Executions themselves only record basic information about the step and cannot be directly nested.

The full set of Execution columns can be found in Table~\ref{tbl:Execution}.

\coltable{Execution}

\subsection{Run}
\label{sec:run}

\tblref{Run} is specialization of Execution used to capture coarse provenance.
Every Dataset and \hyperref[sec:quantum]{Quantum} must be associated with a Run.

For Datasets produced by SuperTask Pipelines, a Run represents an execution of a single Pipeline with no change to its configuration or the software environment.
Other special Runs may represent raw data ingest mechanisms.

The full set of Run columns can be found in Table~\ref{tbl:Run}.

\coltable{Run}

\subsection{Quantum}
\label{sec:quantum}

\tblref{Quantum} is a specialization of Execution used to capture fine-grained provenance for Datasets produced by SuperTasks.

Each Quantum record is uniquely associated with an Execution record.

The full set of Quantum columns can be found in Table~\ref{tbl:Quantum}.

\coltable{Quantum}

\section{Datastore Information}
\label{sec:datastore-information}

\section{Additional Metadata Tables}
\label{sec:additional-metadata-tables}

\subsection{StorageClass Metadata}
\label{sec:storageclass-metadata}

\subsection{DatasetType Metadata}
\label{sec:datasettype-metadata}

\subsection{DataUnit Metadata}
\label{sec:dataunit-metadata}


\section{Multi-User Environments}
\label{sec:multi-user-environments}

\subsection{Cross-Registry Auto-Increment Keys}
\label{sec:cross-registry-auto-increment-keys}

\subsection{Namespaces for Collections and DatasetTypes}
\label{sec:namespaces-for-collections-and-datasettypes}

\subsection{Combining Layered Databases}
\label{sec:layered-databases}


\end{document}
