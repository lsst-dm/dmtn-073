\documentclass[DM,toc]{lsstdoc}

\usepackage{hyperref}
\usepackage{graphicx}

\newcommand{\tblref}[1]{\hyperref[tbl:#1]{#1}}
\newcommand{\unitref}[1]{\hyperref[unit:#1]{#1}}

\newcommand{\coltable}[1]{
    \begin{table}[htb]
        {
            \footnotesize
            \input{generated/#1_columns}
        }
        \caption{#1 Columns}
        \label{tbl:#1}
    \end{table}
}

\newcommand{\unitinc}[1]{\input{generated/#1_unit}}

\newcommand{\joininc}[1]{\input{generated/#1_join}}


\title{The Gen3 Butler Registry Schema}

\author{Jim Bosch}

\setDocRef{DMTN-073}
\date{2018-02-19}
\setDocUpstreamLocation{\url{https://github.com/lsst-dm/dmtn-073}}

\setDocAbstract{%
Documentation for the SQL schema that will be used to manage datasets in the Gen3 Butler.
}

\setDocChangeRecord{%
\addtohist{}{2018-02-19}{Initial version.}{J.~Bosch}
%\addtohist{1}{yyyy-mm-dd}{Future changes}{Future person}
}

\begin{document}

\maketitle

\section{Overview}
\label{sec:overview}

This document is a human-readable description of the minimal SQL schema that will be used in the Gen3 Butler's Registry component.

While some Registry instances may have additional tables, all must provide at least the tables and views described here, and are generally expected to use the mechanisms described here for most extensions.

The normative, machine-readable version of the minimal schema can be found at:

\verb`daf_butler:config/registry/default_schema.yaml`.

The tables and figures in this document (including the descriptions of table columns) are generated from the contents of that file.

\begin{figure}
    \centering
    \includegraphics[height=0.95\textheight]{generated/relationships}
    \caption{Table Relationships.  Colors are for disambiguation only.}
    \label{fig:relationships}
\end{figure}

\section{Datasets}
\label{sec:datasets}

\subsection{Dataset}
\label{sec:dataset}

The Dataset contains a single record for every discrete unit of data managed by the Registry, and acts as a sort of hub for the rest of the schema: nearly all other tables join to it, either to label datasets (Section~\ref{sec:dataunits}), provide provenance information and define groups (Section~\ref{sec:collections-and-provenance}), or connect to the Datastores that actually store them (Section~\ref{sec:datastore-information}).

Finding a particular dataset (assuming one does not already have the primary key value or provenance information) typically requires three pieces of information:
\begin{itemize}
    \item its \hyperref[sec:DatasetType]{DatasetType} (e.g. \texttt{src});
    \item one or more \hyperref[sec:collections]{Collections} to search;
    \item a set of \hyperref[sec:dataunits]{DataUnit} values.
\end{itemize}

The full set of Dataset columns can be found in Table~\ref{tbl:Dataset}.

\coltable{Dataset}


\subsection{DatasetType}
\label{sec:DatasetType}

A DatasetType captures two properties of a Dataset and associates them with a string name:
\begin{itemize}
    \item a \emph{StorageClass};
    \item a set of \hyperref[sec:dataunits]{DataUnit} keys whose corresponding values must be provided to uniquely identify a \tblref{Dataset} within a \hyperref[sec:collections]{Collection}.
\end{itemize}

StorageClasses are things that Datastores know how to serialize.
They are closely related to the in-memory data structure or class object used by a Dataset, and in most cases they have a one-to-one relationship with those concepts.
In other cases, a StorageClass may just correspond to an intermediate opaque serialization interface (e.g. Python's \texttt{pickle}) that can be used to store objects of many different types.
Opaque StorageTypes generally severely limit the flexibility of Datastores to choose how objects are stored and make it impossible to retreive components or slices from those datasets, but they provide a way to save almost-arbitrary objects to Datastores without adding a new StorageClass each time.
Because the full set of StorageClasses must in general be known to all Datastores, the set of supported StorageClasses and their definitions is maintained in code, not any particular Registry.

DatasetTypes are expected to be much more dynamic than StorageClasses or \hyperref[sec:dataunits]{DataUnits}; developers should be able to easily define new DatasetTypes by mixing an existing StorageClass with a set of existing \hyperref[sec:dataunits]{DataUnits} and a new name.
We nevertheless expect DatasetType creation to be quite rare compared with Dataset creation, and certain Registries may limit DatasetType creation to superusers or require adherence to strict naming conventions (see Section~\ref{sec:namespaces-for-collections-and-datasettypes}).

The columns of the DatasetType table itself are shown in Table~\ref{tbl:DatasetType}.
The list of associated \hyperref[sec:dataunits]{DataUnits} is managed by the \tblref{DatasetTypeUnits} table, and a list of associated metadata tables (see Section~\ref{sec:datasettype-metadata}) is managed by the \tblref{DatasetTypeMetadata} table.

\coltable{DatasetType}
\coltable{DatasetTypeUnits}
\coltable{DatasetTypeMetadata}


\subsection{Composite Datasets}
\label{sec:composite-datasets}

Datasets may be composite: they may contain discrete named child Datasets that can be retrieved efficiently from a parent or combined to form a new parent.

The structure of composite dataset is fully defined by its StorageClass; all Datasets with a particular StorageClass will have the same set of component nnames and component StorageClasses (though some StorageClasses may permit a component to be None/null).

When a DatasetType is registered with a StorageClass that has components, DatasetTypes for those components are automatically created as well.
The entries in DatasetTypeUnits for these child DatasetTypes will be the same as those for the parent, and the names for the children will have the form \texttt{\{parent-dataset-name\}.\{component-name\}}.

\coltable{DatasetComposition}.

Both parent/composite datasets and child/component Datasets always have entries in the Dataset table, and these are related by the entries of the \tblref{DatasetComposition} table.

Some Datasets are \emph{virtual composites}, which means that they are not
directly stored in any Datastore.
These are instead assembled entirely from their components using an ``Assembler'' function stored in the Dataset table's \texttt{assembler} field.
Note that virtual composites are still ``more than the sum of their parts'' from a Registry perspective.
They have their own entries in the Dataset table, a number of entries in the \tblref{DatasetComposition} table, and potentially entries one or more \hyperref[sec:metadata]{metadata} tables.
This means that they must be explicitly created (though unlike other datasets, this can be done without a Datastore) before they can be retreived.

\section{DataUnits}
\label{sec:dataunits}

A DataUnit is a predefined discrete unit of data that can be used to label a Dataset, such as a \unitref{Visit} or \unitref{Tract}.
Together, the set of DataUnits are the keys that may be used in data ID dicts, but DataUnits can also be associated with additional metadata fields and other DataUnits.
These relationships and metadata fields are predefined and managed by the Registry, and are hence a major part of the common Registry schema described by this document.

All of the concrete DataUnits described in this section play the same role in how they relate to Datasets, but they can have very different representations in the SQL schema.

All DataUnits have one or more \textbf{Value Fields}, which provide links to the Dataset table.
A DataUnit's own Value Fields are not necessarily sufficient to uniquely identify its instances, however; DataUnits can have \textbf{Dependencies}, which are other DataUnits whose Value Fields must \emph{also} be provided (recursively) for uniqueness.

Not all DataUnits have tables.
Those that do have a (typically) compound primary key that includes its Value Fields and those of its Dependencies (again, recursively).
A DataUnit table can also have a foreign key constraint that is not a Dependency; for example, a \unitref{Visit} has a foreign key to \unitref{PhysicalFilter}, but the \unitref{PhysicalFilter} is not part of \unitref{Visit}'s compound primary key.

\subsection{Fundamental DataUnits}
\label{sec:fundamental-dataunits}

Fundamental DataUnits are those that are not associated with a \unitref{Camera} or \unitref{SkyMap}.

\unitinc{Label}
\unitinc{AbstractFilter}
\unitinc{SkyPix}

\subsection{Camera DataUnits}
\label{sec:camera-dataunits}

Camera DataUnits are associated with a particular observatory and instrument, and are generally customized by a particular \texttt{obs} package.

Some Camera DataUnits are populated when a Camera is first defined within a Registry (\unitref{Camera}, \unitref{PhysicalFilter}, \unitref{Sensor}), while others are created when observations are ingested (\unitref{Exposure}, \unitref{Visit}).

\unitref{ExposureRange}s are unique among Camera DataUnits in being defined directly by the existence of one or more Datasets that use them.
All other Camera DataUnits have their own tables that contain entries that are independent of any particular Dataset (and are typically each associated with many Datasets).

Each combination of \unitref{Visit} and \unitref{Sensor} is also associated with an entry in another table, \tblref{VisitSensorRegion}, which holds the spatial region on the sky associated with each such combination.

\unitinc{Camera}
\unitinc{PhysicalFilter}
\unitinc{Sensor}
\unitinc{Exposure}
\unitinc{Visit}
\coltable{VisitSensorRegion}
\unitinc{ExposureRange}

\subsection{SkyMap DataUnits}
\label{sec:skymap-dataunits}

SkyMap DataUnits together define a two-level subdivision of the sky with overlaps, suitable for coaddition and coadd processing.

\unitinc{SkyMap}
\unitinc{Tract}
\unitinc{Patch}

\subsection{Joins Between DataUnits}
\label{sec:joins-between-dataunits}

Many predefined DataUnit relationships are many-to-many, and hence are not captured in the descriptions of individual DataUnits above.
Some of these relationships can be implemented as join tables or views, but others are just SQL expressions that can be used in a SELECT statement's JOIN clause.

The complete set of conceptual DataUnit relationships is shown in Figure~\ref{fig:DataUnitJoins}.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{DataUnitJoins}
    \includegraphics[width=\textwidth]{DataUnitJoinsLegend}
    \caption{DataUnit Conceptual Joins}
    \label{fig:DataUnitJoins}
\end{figure}

\joininc{ExposureRangeJoin}
\joininc{MultiCameraExposureJoin}
\joininc{VisitSensorSkyPixJoin}
\joininc{VisitSkyPixJoin}
\joininc{PatchSkyPixJoin}
\joininc{TractSkyPixJoin}
\joininc{VisitSensorPatchJoin}
\joininc{VisitPatchJoin}
\joininc{VisitSensorTractJoin}
\joininc{VisitTractJoin}

\section{Collections and Provenance}
\label{sec:collections-and-provenance}

\subsection{Collections}
\label{sec:collections}

A Collection is a group of Datasets that is constrained to have at most one Dataset for any combination of DatasetType and identifying DataUnits.
The inputs and outputs of a particular processing run is typically associated with a Collection, as are human-curated combinations of related processing runs.

Only one Collection within a Registry is accessible to any Butler client, making them from a user perspective the most natural analog to the Gen2 Butler's Data Repositories.
The constraint on Dataset uniqueness within a Collection ensures that any \texttt{Butler.get} call has an unambiguous result.
Instead of lazily chaining Collections in the manner of Gen2 Data Repositories, we simply permit Datasets to belong to multiple Collections.

Collections are implemented via a simple tag table, \tblref{DatasetCollection}, whose entries are just tuples of a \texttt{dataset\_id} and the string name that identifies the Collection.

It may be necessary for performance reasons to introduce an integer primary key for Collections, along with a table to relate each Collection name to its primary key (and possibly other metadata).
Doing this now seems premature.

\coltable{DatasetCollection}

\subsection{Execution}
\label{sec:excution}

Records of the \tblref{Execution} table can be used to represent any step in a production.
Executions are frequently associated one-to-one with records of other tables that use the same primary key fields (such as \hyperref[sec:run]{Run} and \hyperref[sec:quantum]{Quantum}).
Conceptually these tables are Execution specializations.
Executions themselves only record basic information about the step and cannot be directly nested.

The full set of Execution columns can be found in Table~\ref{tbl:Execution}.

\coltable{Execution}

\subsection{Run}
\label{sec:run}

\tblref{Run} is specialization of Execution used to capture coarse provenance.
Every Dataset and \hyperref[sec:quantum]{Quantum} must be associated with a Run.

For Datasets produced by SuperTask Pipelines, a Run represents an execution of a single Pipeline with no change to its configuration or the software environment.
Other special Runs may represent raw data ingest mechanisms.

The full set of Run columns can be found in Table~\ref{tbl:Run}.

\coltable{Run}

\subsection{Quantum}
\label{sec:quantum}

\tblref{Quantum} is a specialization of Execution used to capture fine-grained provenance for Datasets produced by SuperTasks.

Each Quantum record is uniquely associated with an Execution record.

The full set of Quantum columns can be found in Table~\ref{tbl:Quantum}.

\coltable{Quantum}

\section{Datastore Information}
\label{sec:datastore-information}

The \tblref{DatasetStorage} table provides public information about how Datasets are stored in particular Datastores.  This includes whether they are present at all, which is indicated by the existence of a record with a particular Dataset/Datastore combination.

\coltable{DatasetStorage}

This table is unique among Registry tables in that it is updated directly by Datastore, rather than via Butler (whether this goes through a Registry client or some other common interface to the database is TBD).
In general, Datastores must also record private information about each Dataset (e.g. filenames, read formatters).
These entries may be stored in additional tables in the same database that holds the Registry, but may also be stored elsewhere.

\section{Additional Metadata Tables}
\label{sec:metadata}

\subsection{StorageClass Metadata}
\label{sec:storageclass-metadata}

\subsection{DatasetType Metadata}
\label{sec:datasettype-metadata}

\subsection{DataUnit Metadata}
\label{sec:dataunit-metadata}


\section{Multi-User Environments}
\label{sec:multi-user-environments}

\subsection{Cross-Registry Auto-Increment Keys}
\label{sec:cross-registry-auto-increment-keys}

\subsection{Namespaces for Collections and DatasetTypes}
\label{sec:namespaces-for-collections-and-datasettypes}

\subsection{Combining Layered Databases}
\label{sec:layered-databases}


\end{document}
